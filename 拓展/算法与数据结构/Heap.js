/***
 * 定义
 * 实现：堆是用数组实现的完全二叉树
 * 优先队列: 一种特殊的队列，队列中元素出栈的顺序是按照元素的优先权大小，而不是元素入队的先后顺序。
 * 特性：1：必须是完全二叉树；2：用数组实现；3：任意结点的值是其子树所有结点的最大值或最小值(最大值：大顶堆/最大堆；最小值：小顶堆/最小堆)
 * 对于堆这种数据结构，从根结点到任意结点路径上所有的结点都是有序的。
 * 可操作集:1：创建一个空的堆；2：判断堆是否已满；3：将元素插入堆；4：判断最大堆是否为空；5：返回堆中最大元素
 */

 //以最大堆为例


 /**
  * 思路：1：完全二叉树；2：任一结点的值是其左右子树的最大值；3：用数组实现
  */

	//这里为了方便，我们直接占用了数组下标为0的位置，在0的位置放置一个null，这样数组中实际有效值的下标就和我们完全二叉树中序遍历的实际序号对应了。这样，完全二叉树中，
	//如果结点值为n，那么其左子树则为2n，右子树为2n+1;换句话说，对于任一结点n,其父结点为n/2取整即可
	//创建一个堆
const MaxHeap = function(){
    let mHeap = [];
		mHeap.push(null);
		return mHeap;
}

//堆的插入操作

const insert = function(value) {
	let maxHeap = MaxHeap();
	//新插入的元素首先放在堆得最后一个位置
	maxHeap.push(value);
	//获取最后一个元素在数组的位置，注意是从index=1的位置开始添加的
	let index = maxHeap.length - 1;

	//其父结点的位置
	let pIndex = index / 2;

	//在数组范围内，比较这个插入值和父结点的大小关系，大于父结点则用父结点替换当前值，index位置上的值上升为父结点
	while(index>1){
		//如果父结点大于插入值，则不需要调整
		if(mHeap(pIndex)>= value){
			break;
		}else {
			//依次把父结点较小的值“降”下来
			maxHeap[index] = maxHeap[pIndex];
			//向上升一层
			index = pIndex;
			//新的父结点诞生
			pIndex = index /2;
		}
	}
	//最后找到index的位置，把值放进去
	mHeap[index] = value;
}
